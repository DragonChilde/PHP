# WIN10下安装WSL2的Ubuntu1804

安装WSL1

```
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
```

更新到WSL2

```
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
```

设定WSL2为默认

```
wsl --set-default-version 2
```

当设置有异常时,点击进入下面链接https://aka.ms/wsl2kernel ，更新 WSL 2 Linux 内核

在win10 store商店选择Ubuntu18.04下载安装

启动应用时会让输入初始账号密码

Ubuntu的默认root密码是随机的，
即每次开机都有一个新的root密码。我们可以在终端输入命令 sudo passwd，
然后输入当前用户的密码，enter，终端会提示我们输入新的密码并确认，
此时的密码就是root新密码。修改成功后，输入命令 su root，再输入新的密码就ok了

修改WSL默认登陆用户为root,在cmder下执行:

```
ubuntu1804 config --default-user root
```

系统初始化

调整更新镜像地址,[阿里巴巴提供的 Ubuntu 软件源镜像地址](https://developer.aliyun.com/mirror/ubuntu)

然后运行如下命令更新并升级这个 Ubuntu 系统

```
sudo apt update
sudo apt upgrade
```


# 卸载PHP

删除php的相关包及配置

```
$ sudo apt-get autoremove php7*
```

删除关联

```
$ sudo find /etc -name "*php*" |xargs  rm -rf 
```

清除dept列表

```
$ sudo apt purge `dpkg -l | grep php| awk '{print $2}' |tr "\n" " "`
```

检查是否卸载干净

```
$  dpkg -l | grep php
```

# 安装PHP7.3

```
$ sudo apt-get install python-software-properties
$ sudo add-apt-repository ppa:ondrej/php
$ sudo apt-get update
$ sudo apt-get install -y php7.3
```

# 安装PHP 7模块

你还可能需要根据你的应用程序需求安装模块。使用以下命令在包存储库中搜索可用的PHP 7模块。

```
$ sudo apt-cache search php7*
```

你可以按照下面的命令在系统上安装所需的PHP模块。通过指定带有包名的版本，确保安装正确的PHP版本的包。在不定义包版本的情况下，它将安装最新的包。

```
$ sudo apt-get install php7.3-bcmath php7.3-bz2 php7.3-cgi php7.3-cgi php7.3-common php7.3-curl php7.3-dba php7.3-dev php7.3-enchant php7.3-fpm php7.3-gd php7.3-gmp php7.3-imap php7.3-interbase php7.3-intl php7.3-json php7.3-ldap php7.3-mbstring php7.3-mysql php7.3-odbc php7.3-opcache php7.3-pgsql php7.3-phpdbg php7.3-pspell php7.3-readline php7.3-recode php7.3-snmp php7.3-soap php7.3-sqlite3 php7.3-sybase php7.3-tidy php7.3-xml php7.3-xmlrpc php7.3-xsl php7.3-zip 
```

# 删除APACHE

如果安装了Apache，要先卸载Apache或者能够更换Apache的端口？卸载命令如下（新系统/没安装不必卸载）

```
$ service apache2 stop
$ sudo apt-get --purge remove apache2
$ sudo apt-get --purge remove apache2.2-common
$ sudo apt-get --purge remove libapache2-svn
$ sudo apt-get autoremove
```

（关键一步）找到没有删除掉的配置文件，一并删除

```
$ sudo find /etc -name "*apache*" -exec  rm -rf {} \;
```

# 安装Nginx

安装Nginx命令如下

```
$ apt-get -y install nginx
```

完成后，启动Nginx命令如下

```
$ service nginx start
```

输入IP地址或域名在浏览器访问，显示成功安装Nginx

# **配置Nginx**

打开配置文件nginx.conf 命令如下

```
vim /etc/nginx/nginx.conf
```

找到nginx.conf配置文件里的keepalive_timeout变量把它的值改成2，如下（如何修改文件内容，见本文开头常用命令vim）

```
http {

        ##
        # Basic Settings
        ##

        sendfile on;
        tcp_nopush on;
        tcp_nodelay on;
        keepalive_timeout 2;
        types_hash_max_size 2048;
        # server_tokens off;

        ......
```

接下来打开配置文件sites-available/default 命令如下

```
vim /etc/nginx/sites-available/default
```

打开后，按照如下部分修改（主要就是把前面"#"注释标志删掉，让PHP生效。注意函数的大括号“}”不要忘了取消注释）

```
server {
        listen 80 default_server;
        listen [::]:80 default_server;

        # SSL configuration
        #
        # See: https://bugs.debian.org/773332
        #
        # Read up on ssl_ciphers to ensure a secure configuration.
        # See: https://bugs.debian.org/765782
        #
        # Self signed certs generated by the ssl-cert package
        # Don't use them in a production server!
        #
        # include snippets/snakeoil.conf;

        root /var/www/html;

        # Add index.php to the list if you are using PHP
        index index.php index.html index.htm index.nginx-debian.html;

        server_name _;

        location / {
                # First attempt to serve request as file, then
                # as directory, then fall back to displaying a 404.
                try_files $uri $uri/ =404;
        }

        # pass PHP scripts to FastCGI server
        #
        location ~ \.php$ {
                include snippets/fastcgi-php.conf;
        #
        #       # With php-fpm (or other unix sockets):
                fastcgi_pass unix:/var/run/php/php7.3-fpm.sock;
        #       # With php-cgi (or other tcp sockets):
        #       fastcgi_pass 127.0.0.1:9000;
        }

        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        location ~ /\.ht {
                deny all;
        }
}
```

两个文件都修改完后，重新加载一下nginx 命令如下

```
$ service nginx reload
```

# **配置PHP**

这里要注意：php的配置文件php.ini，路径会随PHP版本而不同，所以首先查找php.ini文件位置 命令如下

```
$ php -i | grep php.ini
```

```
root@DESKTOP-933NN47:/var/www# php -i | grep php.ini
Configuration File (php.ini) Path => /etc/php/7.3/cli
Loaded Configuration File => /etc/php/7.3/cli/php.ini
```

命令的意思是：php -i 即显示php的详细信息，然后在其中匹配php.ini的信息，如上图找到了路径是 /etc/php/7.3/cli/php.ini，接下来就是打开这个文件

```
vim /etc/php/7.3/cli/php.ini
```

然后输入/cgi.fix_pathinfo 查询，找到后回车，按 I 进入编辑模式，修改文件内容cgi.fix_pathinfo = 0，记得前面的分号  ; （注释！）要删掉。

```
; cgi.fix_pathinfo provides *real* PATH_INFO/PATH_TRANSLATED support for CGI.  PHP's
; previous behaviour was to set PATH_TRANSLATED to SCRIPT_FILENAME, and to not grok
; what PATH_INFO is.  For more information on PATH_INFO, see the cgi specs.  Setting
; this to 1 will cause PHP CGI to fix its paths to conform to the spec.  A setting
; of zero causes PHP to behave as before.  Default is 1.  You should fix your scripts
; to use SCRIPT_FILENAME rather than PATH_TRANSLATED.
; http://php.net/cgi.fix-pathinfo
cgi.fix_pathinfo=0
```

修改完成后重新加载PHP服务命令如下（还是一样，根据自己版本号确定服务名。不知道自己服务名的输入以下命令查看

```
$ service --status-all
```

重启php7.3-fpm

```
$ service php7.3-fpm reload
```

建立phpinfo文件查看是否配置成功

# 安装ICE服务

依赖安装

```
$ sudo apt-get install libbz2-dev liblmdb-dev libmcpp-dev libmcpp-dev libssl-dev libexpat1-dev dpkg-dev pkg-config libdbus-1-dev libbluetooth-dev
```

git源码下载

```
git clone https://github.com/zeroc-ice/ice.git
```

进入ICE源码,编译 cpp(途中有报错说明缺少对应的依赖)

```
$ cd ice/cpp
$ make
```

安装,会自动生成文件夹 /opt/Ice-3.7.4

```
$ make intall
```

指定环境变量

```
$ export PATH=/opt/Ice-3.7.2/bin:$PATH
$ vim ~/.bashrc
在文件末尾添加 PATH=/opt/Ice-3.7.2/bin:$PATH
执行使之生效
$ source ~/.bashrc
```

复制需要加载的动态库配置文件

```
$ echo /opt/Ice-3.7.4/lib/x86_64-linux-gnu > /etc/ld.so.conf.d/ice.conf
```

刷新配置使之生效

```
$ ldconfig
```

验证ice是否安装成功,成功显示ICE版本号

```
$ slice2php -v
```

编译PHP-ICE,进入ICE源码包下的php

```
$ cd ./php
$ make && make install
```

成功后会在/opt/Ice-3.7.4/php目录下生成ice.so扩展文件

根据php.ini的位置指明ice.so扩展位置,下面是查看php.ini位置

```
$ php -i | grep php.ini
```

查看模块安装情况

```
$ php -m
```

如在php-cli端成功显示,要在php-fpm phpinfo()页面成功显示ice扩展,编辑动态加载库配置

```
$ vim /etc/ld.so.conf
```

把ice.so文件的目录添加进去

```
/usr/lib/php/20180731
```

刷新配置,重启服务使之生效

```
$ ldconfig
$ service nginx restart
$ service php7.3-fpm restart
```



# 配置SSH远程登录

> 注意:必须重装系统自带的SSH

```
$ sudo apt remove openssh-server
$ sudo apt install openssh-server
```

WSL上的Ubuntu默认安装了openssh-server，也就是ssh服务的软件。但是，这个软件的配置是不完整的，如果启用服务，会报缺失几个密钥文件。为了解决这个问题，我们需要重新安装openssh-server,重新安装完还不行，因为WSL上的Ubuntu的SSH服务配置默认不允许密码方式登录，我们需要改配置

更改配置

```
$ sudo vim /etc/ssh/sshd_config
```

```

Port 2222   #设置ssh的端口号, 由于22在windows中有别的用处, 尽量不修改系统的端口号
PermitRootLogin yes   # 可以root远程登录
PasswordAuthentication yes     # 允许密码验证登录
AllowUsers root # 远程登录时的用户名
```

重启SSH服务

```
$ sudo service ssh --full-restart
```

用SecureCRT登录localhost:2222(如root密码忘记可使用以下方法重置root密码)

在cmd下输入

```
ubuntu1804 config --default-user root
```

修改root密码

```
$ passwd root
```

# 安装MYSQL

删除mysql

```
$ sudo apt-get autoremove --purge mysql-server
$ sudo apt-get remove mysql-common
```

清理残留数据

```
$ dpkg -l |grep ^rc|awk '{print $2}' |sudo xargs dpkg -P 
```

安装Mysql

```
$ sudu apt install mysql-server
```

启动时报错：`No directory, logging in with HOME=/`，目录权限问题。解决方法是修改权限：

```
$ sudo service mysql stop  #先停止服务
$ sudo usermod -d /var/lib/mysql/ mysql #修改目录权限
$ sudo service mysql start #启动MySQL
```

重新设置密码

```
$ sudo mysql_secure_installation
```

```
#1选y，前面提示大致的意思是：默认使用空的密码连接，该种连接方式可以作为测试使用，但是不安全，问是否要重新设置密码
VALIDATE PASSWORD PLUGIN can be used to test passwords...
Press y|Y for Yes, any other key for No: y

#2
Please set the password for root here...
New password: (输入密码)
Re-enter new password: (重复输入)

#3是否移除匿名用户，匿名用户留着也没什么用，可以移除掉
By default, a MySQL installation has an anonymous user,
allowing anyone to log into MySQL without having to have
a user account created for them...
Remove anonymous users? (Press y|Y for Yes, any other key for No) : y

#4是否禁止root用户远程登录，在没有设置其他用户之前，只能通过root用户登录，所以不能禁止
Normally, root should only be allowed to connect from
'localhost'. This ensures that someone cannot guess at
the root password from the network...
Disallow root login remotely? (Press y|Y for Yes, any other key for No) : n

#5是否移除测试数据库
By default, MySQL comes with a database named 'test' that
anyone can access...
Remove test database and access to it? (Press y|Y for Yes, any other key for No) : n

#6是否重新载入特权表，最好不动它
Reloading the privilege tables will ensure that all changes
made so far will take effect immediately.
Reload privilege tables now? (Press y|Y for Yes, any other key for No) : n

```

这时是无法远程链接的,需要对root用户进行配置

```
$ mysql -uroot -p
$ GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;
$ flush privileges; #刷新修改配置
```

第一个 'root'@''%''，`localhost`就是本地访问，配置成`%`就是所有主机都可连接；

第二个`'123456'`为你给新增权限用户设置的密码，

修改完后还没可以登录,

```
$ use mysql;
$ select user, plugin from mysql.user;
```

查询可以发现,root的plugin设置错误,远程登录会报 ERROR 1698

```
+------------------+-----------------------+
| user             | plugin                |
+------------------+-----------------------+
| root             | auth_socket 		  |
| mysql.session    | mysql_native_password |
| mysql.sys        | mysql_native_password |
| debian-sys-maint | mysql_native_password |
| root             | mysql_native_password |
+------------------+-----------------------+
```

需要对plugin进行设置

```
$ update mysql.user set authentication_string=PASSWORD('123456'), plugin='mysql_native_password' where user='root';
$ flush privileges; #刷新配置,现在可以进行远程登录了
```

编码设置

安装好的mysql默认有很多是`latin1`的编码格式，对汉字的支持不好，因此需要改成`utf8`编码格式,t先把mysql服务停止

```
$ service mysql stop
#修改配置文件
$ cd /etc/mysql/mysql.conf.d
#修改之前先备份
$ cp mysqld.cnf mysqld.cnf.bak
$ vim mysqld.cnf
```

```
# 修改处1：添加以下2行 
[client] 
default-character-set=utf8

[mysqld]
# 修改处2：添加以下3行 
default-storage-engine=INNODB
character-set-server=utf8 
collation-server=utf8_general_ci
```

完成后重启数据库,过入重新查看编码格式都是utf8

```
mysql> show variables like 'character%';
+--------------------------+----------------------------+
| Variable_name            | Value                      |
+--------------------------+----------------------------+
| character_set_client     | utf8                       |
| character_set_connection | utf8                       |
| character_set_database   | utf8                       |
| character_set_filesystem | binary                     |
| character_set_results    | utf8                       |
| character_set_server     | utf8                       |
| character_set_system     | utf8                       |
| character_sets_dir       | /usr/share/mysql/charsets/ |
+--------------------------+----------------------------+
8 rows in set (0.00 sec)
```

# 其它问题

## WSL2 linux权限问题 chmod(): Operation not permitted

wsl在mount windows系统到linux系统文件列表时候，所以权限都是777，但是在php执行chmod函数的时候，会提示“ chmod(): Operation not permitted”,解决方法

```
vim /etc/wsl.conf

# 添加下面内容
[automount]
enabled = true
root = /mnt/
options = "metadata,umask=22,fmask=111"
mountFsTab = true
[filesystem]
umask = 022
```

重启WSL

```
# 管理员权限启动windows cmd命令行
net.exe stop LxssManager
```

之后在进入wsl系统，mnt目录下的文件权限会恢复到正常的权限；

## nginx无法访问Laravel,yii下的自定义url

在该域名的`server`添加 `try_files $uri uri/ /index.php?query_string; `

```nginx
location / {                                                   
	# First attempt to serve request as file, then         	
	# as directory, then fall back to displaying a 404.    
	#try_files $uri $uri/ =404;                            
	try_files $uri uri/ /index.php?query_string;           
}                                                              
```

